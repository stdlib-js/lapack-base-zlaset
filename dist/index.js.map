{
  "version": 3,
  "sources": ["../lib/base.js", "../lib/zlaset.js", "../lib/ndarray.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major' );\nvar reinterpret = require( '@stdlib/strided-base-reinterpret-complex128' );\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar real = require( '@stdlib/complex-float64-real' );\nvar imag = require( '@stdlib/complex-float64-imag' );\nvar min = require( '@stdlib/math-base-special-fast-min' );\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a double-precision complex floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 3, 1.0, 2.0, A, 6, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 3, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = breal;\n\t\tA[ ia+1 ] = bimag;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setAll( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Fill the array with a scalar value...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = areal;\n\t\t\tA[ ia+1 ] = aimag;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\t// Replace the diagonal:\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*/\nfunction setUpper( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the lower triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setLower( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia + ( i1*strideA1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar viewA;\n\tvar ar;\n\tvar ai;\n\tvar br;\n\tvar bi;\n\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\n\t// Adjust the strides and offset accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\n\toffsetA *= 2;\n\n\t// Decompose the scalars to real and imaginary components:\n\tar = real( alpha );\n\tai = imag( alpha );\n\tbr = real( beta );\n\tbi = imag( beta );\n\n\tif ( uplo === 'upper' ) {\n\t\tsetUpper( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else if ( uplo === 'lower' ) {\n\t\tsetLower( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else {\n\t\tsetAll( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaset;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isLayout = require( '@stdlib/blas-base-assert-is-layout' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex128Array} `A`\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'upper', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'lower', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( order === 'column-major' ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaset;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaset;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar zlaset = require( './zlaset.js' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\nsetReadOnly( zlaset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nmodule.exports = zlaset;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @module @stdlib/lapack-base-zlaset\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-float64' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n* var zlaset = require( '@stdlib/lapack-base-zlaset' );\n*\n* var A = new Complex128Array( 4 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z )\n* // returns 4.0\n*\n* @example\n* var Complex128Array = require( '@stdlib/array-float64' );\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n* var zlaset = require( '@stdlib/lapack-base-zlaset' );\n*\n* var A = new Complex128Array( 5 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset.ndarray( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nvar tryRequire = require( '@stdlib/utils-try-require' );\nvar isError = require( '@stdlib/assert-is-error' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nvar zlaset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaset = main;\n} else {\n\tzlaset = tmp;\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaset;\n\n// exports: { \"ndarray\": \"zlaset.ndarray\" }\n"],
  "mappings": "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",
  "names": ["require_base", "__commonJSMin", "exports", "module", "isRowMajor", "reinterpret", "loopOrder", "real", "imag", "min", "setDiagonal", "M", "N", "breal", "bimag", "A", "strideA1", "strideA2", "offsetA", "sa", "ia", "i", "setAll", "areal", "aimag", "da0", "da1", "sh", "S0", "S1", "i0", "i1", "o", "setUpper", "idx", "setLower", "zlaset", "uplo", "alpha", "beta", "viewA", "ar", "ai", "br", "bi", "require_zlaset", "__commonJSMin", "exports", "module", "isLayout", "format", "base", "zlaset", "order", "uplo", "M", "N", "alpha", "beta", "A", "LDA", "sa1", "sa2", "require_ndarray", "__commonJSMin", "exports", "module", "base", "zlaset", "uplo", "M", "N", "alpha", "beta", "A", "strideA1", "strideA2", "offsetA", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "zlaset", "ndarray", "join", "tryRequire", "isError", "main", "zlaset", "tmp"]
}
