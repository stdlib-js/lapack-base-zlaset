{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/zlaset.js","../lib/main.js","../lib/ndarray.js","../lib/index.js","../83ab38c474f28a619db925d496434f"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major';\nimport reinterpret from '@stdlib/strided-base-reinterpret-complex128';\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport real from '@stdlib/complex-float64-real';\nimport imag from '@stdlib/complex-float64-imag';\nimport min from '@stdlib/math-base-special-fast-min';\n\n\n// FUNCTIONS //\n\n/**\n* Sets the diagonal of a double-precision complex floating-point matrix `A` to a specified value.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 3, 1.0, 2.0, A, 6, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 2, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* setDiagonal( 3, 2, 1.0, 2.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0 ]\n*/\nfunction setDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA ) {\n\tvar sa;\n\tvar ia;\n\tvar i;\n\n\tsa = strideA1 + strideA2;\n\tia = offsetA;\n\tfor ( i = 0; i < min( M, N ); i++ ) {\n\t\tA[ ia ] = breal;\n\t\tA[ ia+1 ] = bimag;\n\t\tia += sa;\n\t}\n\treturn A;\n}\n\n/**\n* Sets all elements of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setAll( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setAll( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar da0;\n\tvar da1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sa;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar o;\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( [ M, N ], [ strideA1, strideA2 ] );\n\tsh = o.sh;\n\tsa = o.sx;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tS1 = sh[ 1 ];\n\tda0 = sa[ 0 ];\n\tda1 = sa[ 1 ] - ( S0*sa[0] );\n\n\t// Set the pointer to the first indexed element:\n\tia = offsetA;\n\n\t// Fill the array with a scalar value...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tA[ ia ] = areal;\n\t\t\tA[ ia+1 ] = aimag;\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t}\n\t// Replace the diagonal:\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\n\treturn A;\n}\n\n/**\n* Sets the upper triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setUpper( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*/\nfunction setUpper( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia + ( i1*strideA2 );\n\t\t\tfor ( i0 = i1; i0 < N; i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia;\n\t\tfor ( i0 = 0; i0 <= min( i1, M-1 ); i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n/**\n* Sets the lower triangular/trapezoidal part of a double-precision complex floating-point matrix `A` to specified values.\n*\n* @private\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {number} areal - real component of the value to assign to off-diagonal elements\n* @param {number} aimag - imaginary component of the value to assign to off-diagonal elements\n* @param {number} breal - real component of the value to assign to diagonal elements\n* @param {number} bimag - imaginary component of the value to assign to diagonal elements\n* @param {Float64Array} A - input matrix view\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Float64Array} `A`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, 2, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 4, -2, 2 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, 2, 4 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -4, -2, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, 4, 0 );\n* // A => <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 0.0, 0.0, 3.0, 4.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, 4, 2 );\n* // A => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 3.0, 4.0, 0.0, 0.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, 2, -4, 4 );\n* // A => <Float64Array>[ 0.0, 0.0, 3.0, 4.0, 3.0, 4.0, 1.0, 2.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var A = new Float64Array( 8 );\n* // returns <Float64Array>[ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]\n*\n* setLower( 2, 2, 1.0, 2.0, 3.0, 4.0, A, -2, -4, 6 );\n* // A => <Float64Array>[ 3.0, 4.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction setLower( M, N, areal, aimag, breal, bimag, A, strideA1, strideA2, offsetA ) { // eslint-disable-line max-len\n\tvar idx;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\n\tia = offsetA;\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tfor ( i1 = 0; i1 < M; i1++ ) {\n\t\t\tidx = ia;\n\t\t\tfor ( i0 = 0; i0 <= min( i1, N-1 ); i0++ ) {\n\t\t\t\tA[ idx ] = areal;\n\t\t\t\tA[ idx+1 ] = aimag;\n\t\t\t\tidx += strideA2;\n\t\t\t}\n\t\t\tia += strideA1;\n\t\t}\n\t\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\t\treturn A;\n\t}\n\tfor ( i1 = 0; i1 < N; i1++ ) {\n\t\tidx = ia + ( i1*strideA1 );\n\t\tfor ( i0 = i1; i0 < M; i0++ ) {\n\t\t\tA[ idx ] = areal;\n\t\t\tA[ idx+1 ] = aimag;\n\t\t\tidx += strideA1;\n\t\t}\n\t\tia += strideA2;\n\t}\n\tsetDiagonal( M, N, breal, bimag, A, strideA1, strideA2, offsetA );\n\treturn A;\n}\n\n\n// MAIN //\n\n/**\n* Sets elements of matrix `A` to specified values.\n*\n* @private\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 0 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\tvar viewA;\n\tvar ar;\n\tvar ai;\n\tvar br;\n\tvar bi;\n\n\t// Reinterpret the input array as a real-valued array of interleaved real and imaginary components:\n\tviewA = reinterpret( A, 0 );\n\n\t// Adjust the strides and offset accordingly:\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\n\toffsetA *= 2;\n\n\t// Decompose the scalars to real and imaginary components:\n\tar = real( alpha );\n\tai = imag( alpha );\n\tbr = real( beta );\n\tbi = imag( beta );\n\n\tif ( uplo === 'upper' ) {\n\t\tsetUpper( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else if ( uplo === 'lower' ) {\n\t\tsetLower( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t} else {\n\t\tsetAll( M, N, ar, ai, br, bi, viewA, strideA1, strideA2, offsetA );\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas-base-assert-is-layout';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} order - storage layout of `A`\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} eighth argument must be greater than or equal to `N`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'upper', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 4 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'lower', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 1 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( order, uplo, M, N, alpha, beta, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( order === 'column-major' ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tif ( LDA < N ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Eighth argument must be greater than or equal to %d. Value: `%d`.', N, LDA ) );\n\t\t}\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( uplo, M, N, alpha, beta, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport zlaset from './zlaset.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlaset, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Sets the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @param {string} uplo - specifies whether to set the upper or lower triangular/trapezoidal part of matrix `A`\n* @param {NonNegativeInteger} M - number of rows in matrix `A`\n* @param {NonNegativeInteger} N - number of columns in matrix `A`\n* @param {Complex128} alpha - value assigned to off-diagonal elements\n* @param {Complex128} beta - value assigned to diagonal elements\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - starting index for `A`\n* @returns {Complex128Array} `A`\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'upper', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n*\n* var A = new Complex128Array( 5 );\n*\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'lower', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* z = A.get( 2 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 0.0\n*\n* im = imag( z );\n* // returns 0.0\n*\n* z = A.get( 3 );\n* // returns <Complex128>\n*\n* re = real( z );\n* // returns 1.0\n*\n* im = imag( z );\n* // returns 2.0\n*/\nfunction zlaset( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA ) {\n\treturn base( uplo, M, N, alpha, beta, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to set the off-diagonal elements and the diagonal elements of a double-precision complex floating-point matrix to specified values.\n*\n* @module @stdlib/lapack-base-zlaset\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n* import zlaset from '@stdlib/lapack-base-zlaset';\n*\n* var A = new Complex128Array( 4 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset( 'row-major', 'all', 2, 2, alpha, beta, A, 2 );\n*\n* var z = A.get( 0 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n* import zlaset from '@stdlib/lapack-base-zlaset';\n*\n* var A = new Complex128Array( 5 );\n* var alpha = new Complex128( 1.0, 2.0 );\n* var beta = new Complex128( 3.0, 4.0 );\n*\n* zlaset.ndarray( 'all', 2, 2, alpha, beta, A, 2, 1, 1 );\n*\n* var z = A.get( 1 );\n* // returns <Complex128>\n*\n* var re = real( z );\n* // returns 3.0\n*\n* var im = imag( z );\n* // returns 4.0\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils-try-require';\nimport isError from '@stdlib/assert-is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlaset;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaset = main;\n} else {\n\tzlaset = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlaset;\n\n// exports: { \"ndarray\": \"zlaset.ndarray\" }\n","export default '/home/runner/work/lapack-base-zlaset/lapack-base-zlaset/lib'"],"names":["setDiagonal","M","N","breal","bimag","A","strideA1","strideA2","offsetA","sa","ia","i","min","zlaset","uplo","alpha","beta","viewA","ar","ai","br","bi","reinterpret","real","imag","areal","aimag","idx","i0","i1","isRowMajor","setUpper","setLower","da0","da1","sh","S0","S1","o","loopOrder","sx","setAll","order","LDA","sa1","sa2","isLayout","TypeError","format","RangeError","base","setReadOnly","tmp","tryRequire","join","require$$0","zlaset$1","isError","main"],"mappings":"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"}